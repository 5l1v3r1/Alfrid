{"version":3,"names":[],"mappings":"","sources":["bundle.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n// console.log('alfrid : ', alfrid);\n\n// import glslify from 'glslify';\n\n\nvar cnt = 0;\nvar GL = alfrid.GL;\nvar mesh = void 0,\n    shader = void 0,\n    cameraOrtho = void 0,\n    cameraPersp = void 0,\n    meshPlane = void 0,\n    meshSphere = void 0,\n    batchSphere = void 0,\n    shaderUV = void 0,\n    meshPlane2 = void 0;\nvar texture = void 0;\nvar batchCopy = void 0,\n    batch = void 0,\n    batch2 = void 0;\nvar fbo = void 0;\n\nvar img = new Image();\nimg.onload = function () {\n\tif (window.body) {\n\t\t_init();\n\t} else {\n\t\twindow.addEventListener('load', function () {\n\t\t\treturn _init();\n\t\t});\n\t}\n};\nimg.src = './assets/image.jpg';\n\nwindow.addEventListener('resize', function () {\n\treturn resize();\n});\n\nfunction _init() {\n\t// alfrid.log();\n\n\tvar canvas = document.createElement(\"canvas\");\n\tcanvas.className = 'Main-Canvas';\n\tdocument.body.appendChild(canvas);\n\n\tGL.init(canvas);\n\t// alfrid.GL.showExtensions();\n\n\t//\tLOOPING\n\talfrid.Scheduler.addEF(loop);\n\n\t//\tCREATE CAMERA\n\tcameraOrtho = new alfrid.CameraOrtho();\n\n\tcameraPersp = new alfrid.CameraPerspective();\n\tcameraPersp.setPerspective(45 * Math.PI / 180, GL.aspectRatio, 1, 1000);\n\t// var eye                = vec3.clone( [0, 0, 5]  );\n\t// var center             = vec3.create( );\n\t// var up                 = vec3.clone( [0, 1, 0] );\n\t// cameraPersp.lookAt(eye, center, up);\n\n\tvar orbitalControl = new alfrid.OrbitalControl(cameraPersp, window, 15);\n\torbitalControl.radius.value = 10;\n\n\tGL.setMatrices(cameraPersp);\n\n\t//\tCREATE TEXTURE\n\ttexture = new alfrid.GLTexture(img);\n\n\t//\tCREATE SHADER\n\tshader = new alfrid.GLShader(null, \"// basic.frag\\n\\n#define SHADER_NAME BASIC_FRAGMENT\\n\\nprecision highp float;\\n#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nuniform sampler2D texture;\\nuniform float time;\\n\\nvoid main(void) {\\n    gl_FragColor = texture2D(texture, vTextureCoord);\\n    // gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\\n}\");\n\tshaderUV = new alfrid.GLShader(null, \"// basic.frag\\n\\n#define SHADER_NAME BASIC_FRAGMENT\\n\\nprecision highp float;\\n#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n// uniform sampler2D texture;\\nuniform float time;\\n\\nvoid main(void) {\\n    // gl_FragColor = texture2D(texture, vTextureCoord);\\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\\n}\");\n\tshader.bind();\n\tshader.uniform(\"texture\", \"uniform1i\", 0);\n\ttexture.bind(0);\n\n\t//\tCREATE GEOMETRY\n\tvar positions = [];\n\tvar coords = [];\n\tvar indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7];\n\n\tvar size = 1;\n\tvar xOffset = .5;\n\tpositions.push([-size - xOffset, -size, -0.5]);\n\tpositions.push([size - xOffset, -size, -0.5]);\n\tpositions.push([size - xOffset, size, -0.5]);\n\tpositions.push([-size - xOffset, size, -0.5]);\n\n\tcoords.push([0, 0]);\n\tcoords.push([1, 0]);\n\tcoords.push([1, 1]);\n\tcoords.push([0, 1]);\n\n\tpositions.push([-size + xOffset, -size, 0.5]);\n\tpositions.push([size + xOffset, -size, 0.5]);\n\tpositions.push([size + xOffset, size, 0.5]);\n\tpositions.push([-size + xOffset, size, 0.5]);\n\n\tcoords.push([0, 0]);\n\tcoords.push([1, 0]);\n\tcoords.push([1, 1]);\n\tcoords.push([0, 1]);\n\n\tmesh = new alfrid.Mesh();\n\tmesh.bufferVertex(positions);\n\tmesh.bufferTexCoords(coords);\n\tmesh.bufferIndices(indices);\n\n\t//\tMESH VIA GEOM\n\n\tmeshPlane = alfrid.Geom.plane(7, 7 * 983 / 736, 12, false, 'xz');\n\tmeshPlane2 = alfrid.Geom.plane(1.5, 1.5 * 983 / 736, 1);\n\tmeshSphere = alfrid.Geom.sphere(1, 48);\n\n\t//\tBATCH\n\n\tbatch = new alfrid.Batch(meshPlane, shader);\n\tbatch2 = new alfrid.Batch(meshPlane2, shader);\n\tbatchSphere = new alfrid.Batch(meshSphere, shaderUV);\n\tbatchCopy = new alfrid.BatchCopy();\n\n\t//\tFRAME BUFFER\n\tvar fboSize = 1024 * 2;\n\tfbo = new alfrid.FrameBuffer(fboSize, fboSize, {\n\t\tminFilter: GL.LINEAR_MIPMAP_LINEAR,\n\t\tmagFilter: GL.LINEAR\n\t});\n}\n\nfunction loop() {\n\t/*\n const max = 60 * 5;\n let gray = 0;\n \n GL.enable(GL.DEPTH_TEST);\n GL.viewport(0, 0, GL.width, GL.height);\n fbo.bind();\n GL.setMatrices(cameraPersp);\n GL.clear(0, 0, 0, 0);\n \n //\tWITHOUT BATCH : BIND SHADER THEN DRAW MESH\n \tshader.bind();\n GL.draw(mesh);\n \n //\tDRAWING USING BATCH\n \tbatch.draw();\n batch2.draw();\n shader.uniform(\"time\", \"float\", cnt*.1);\n \n \tshaderUV.bind();\n shaderUV.uniform(\"time\", \"uniform1f\", cnt*.1);\n \n batchSphere.draw();\n fbo.unbind();\n \n GL.setMatrices(cameraOrtho);\n GL.disable(GL.DEPTH_TEST);\n \tGL.viewport(0, 0, GL.width, GL.height);\n batchCopy.draw(fbo.getTexture());\n \tGL.viewport(0, 0, 200, 200/GL.aspectRatio);\n batchCopy.draw(fbo.getDepthTexture());\n \tGL.viewport(200, 0, 100, 100 *983/736);\n batchCopy.draw(texture);\n \n \tif(cnt++ > max) {\n \t// window.location.href = './';\n }\n \t*/\n}\n\nfunction resize() {\n\tGL.setSize(window.innerWidth, window.innerHeight);\n\tcameraPersp.setAspectRatio(GL.aspectRatio);\n}\n\n},{}]},{},[1]);\n"],"file":"bundle.js","sourceRoot":"/source/"}