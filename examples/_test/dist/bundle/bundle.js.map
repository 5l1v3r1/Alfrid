{"version":3,"names":[],"mappings":"","sources":["bundle.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// DispatcherTest.js\n\nvar DispatcherTest = function (_alfrid$EventDispatch) {\n\t_inherits(DispatcherTest, _alfrid$EventDispatch);\n\n\tfunction DispatcherTest() {\n\t\t_classCallCheck(this, DispatcherTest);\n\n\t\t// this.test();\n\n\t\t// window.setTimeout(()=> this.test(), 1000);\n\n\t\tvar _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DispatcherTest).call(this));\n\n\t\twindow.setInterval(function () {\n\t\t\treturn _this.test();\n\t\t}, 1000);\n\t\treturn _this;\n\t}\n\n\t_createClass(DispatcherTest, [{\n\t\tkey: 'test',\n\t\tvalue: function test() {\n\t\t\t// console.log('test');\n\t\t\t// this.dispatchCustomEvent('test', {x:Math.random()});\n\t\t\tthis.trigger('test', { x: Math.random() });\n\t\t}\n\t}]);\n\n\treturn DispatcherTest;\n}(alfrid.EventDispatcher);\n\nexports.default = DispatcherTest;\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\nvar _DispatcherTest = require('./DispatcherTest');\n\nvar _DispatcherTest2 = _interopRequireDefault(_DispatcherTest);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import glslify from 'glslify';\n // console.log('alfrid : ', alfrid);\n\nvar cnt = 0;\nvar GL = alfrid.GL;\nvar mesh = void 0,\n    shader = void 0,\n    cameraOrtho = void 0,\n    cameraPersp = void 0,\n    meshPlane = void 0,\n    meshSphere = void 0,\n    batchSphere = void 0,\n    shaderUV = void 0,\n    meshPlane2 = void 0;\nvar texture = void 0;\nvar batchCopy = void 0,\n    batch = void 0,\n    batch2 = void 0;\nvar fbo = void 0;\nvar tweenNumber = new alfrid.TweenNumber(0, 'expOut');\n\nvar img = new Image();\nimg.onload = function () {\n\tif (window.body) {\n\t\t_init();\n\t} else {\n\t\twindow.addEventListener('load', function () {\n\t\t\treturn _init();\n\t\t});\n\t}\n};\nimg.src = './assets/image.jpg';\n\nwindow.addEventListener('resize', function () {\n\treturn resize();\n});\nwindow.addEventListener('keydown', function (e) {\n\t// console.log(e.keyCode);\n\ttweenNumber.limit(0, window.innerWidth / 2 - 200);\n\tif (e.keyCode == 40) {\n\t\t//\tdown\n\t\ttweenNumber.value = Math.random() * (window.innerWidth - 200);\n\t}\n});\n\nvar dispatcher = new _DispatcherTest2.default();\n\n// dispatcher.addEventListener('test', (o)=>onTest(o));\ndispatcher.on('test', function (o) {\n\treturn onTest(o);\n});\n\nfunction onTest(o) {\n\t// console.log('onTest :', o);\n}\n\nfunction _init() {\n\t// alfrid.log();\n\n\tvar canvas = document.createElement(\"canvas\");\n\tcanvas.className = 'Main-Canvas';\n\tdocument.body.appendChild(canvas);\n\n\tGL.init(canvas);\n\talfrid.GL.showExtensions();\n\n\t//\tLOOPING\n\talfrid.Scheduler.addEF(loop);\n\n\t//\tCREATE CAMERA\n\tcameraOrtho = new alfrid.CameraOrtho();\n\n\tcameraPersp = new alfrid.CameraPerspective();\n\tcameraPersp.setPerspective(45 * Math.PI / 180, GL.aspectRatio, 1, 1000);\n\t// var eye                = vec3.clone( [0, 0, 5]  );\n\t// var center             = vec3.create( );\n\t// var up                 = vec3.clone( [0, 1, 0] );\n\t// cameraPersp.lookAt(eye, center, up);\n\n\tvar orbitalControl = new alfrid.OrbitalControl(cameraPersp, window, 15);\n\torbitalControl.radius.value = 10;\n\n\tGL.setMatrices(cameraPersp);\n\n\t//\tCREATE TEXTURE\n\ttexture = new alfrid.GLTexture(img);\n\n\t//\tCREATE SHADER\n\tshader = new alfrid.GLShader(null, \"// basic.frag\\n\\n#define SHADER_NAME BASIC_FRAGMENT\\n\\nprecision highp float;\\n#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nuniform sampler2D texture;\\nuniform float time;\\n\\nvoid main(void) {\\n    gl_FragColor = texture2D(texture, vTextureCoord);\\n    // gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\\n}\");\n\tshaderUV = new alfrid.GLShader(null, \"// basic.frag\\n\\n#define SHADER_NAME BASIC_FRAGMENT\\n\\nprecision highp float;\\n#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n// uniform sampler2D texture;\\nuniform float time;\\n\\nvoid main(void) {\\n    // gl_FragColor = texture2D(texture, vTextureCoord);\\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\\n}\");\n\tshader.bind();\n\tshader.uniform(\"texture\", \"uniform1i\", 0);\n\ttexture.bind(0);\n\n\t//\tCREATE GEOMETRY\n\tvar positions = [];\n\tvar coords = [];\n\tvar indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7];\n\n\tvar size = 1;\n\tvar xOffset = .5;\n\tpositions.push([-size - xOffset, -size, -0.5]);\n\tpositions.push([size - xOffset, -size, -0.5]);\n\tpositions.push([size - xOffset, size, -0.5]);\n\tpositions.push([-size - xOffset, size, -0.5]);\n\n\tcoords.push([0, 0]);\n\tcoords.push([1, 0]);\n\tcoords.push([1, 1]);\n\tcoords.push([0, 1]);\n\n\tpositions.push([-size + xOffset, -size, 0.5]);\n\tpositions.push([size + xOffset, -size, 0.5]);\n\tpositions.push([size + xOffset, size, 0.5]);\n\tpositions.push([-size + xOffset, size, 0.5]);\n\n\tcoords.push([0, 0]);\n\tcoords.push([1, 0]);\n\tcoords.push([1, 1]);\n\tcoords.push([0, 1]);\n\n\tmesh = new alfrid.Mesh();\n\tmesh.bufferVertex(positions);\n\tmesh.bufferTexCoord(coords);\n\tmesh.bufferIndex(indices);\n\n\t//\tMESH VIA GEOM\n\n\tmeshPlane = alfrid.Geom.plane(7, 7 * 983 / 736, 12, false, 'xz');\n\t// meshPlane  = alfrid.Geom.plane(5, 5, 5, false, 'xz');\n\tmeshPlane2 = alfrid.Geom.plane(1.5, 1.5 * 983 / 736, 1);\n\tmeshSphere = alfrid.Geom.sphere(1, 48);\n\n\t//\tBATCH\n\n\tbatch = new alfrid.Batch(meshPlane, shader);\n\tbatch2 = new alfrid.Batch(meshPlane2, shader);\n\tbatchSphere = new alfrid.Batch(meshSphere, shaderUV);\n\tbatchCopy = new alfrid.BatchCopy();\n\n\t//\tFRAME BUFFER\n\tvar fboSize = 1024 * 2;\n\tfbo = new alfrid.FrameBuffer(fboSize, fboSize, {\n\t\tminFilter: GL.LINEAR_MIPMAP_LINEAR,\n\t\tmagFilter: GL.LINEAR\n\t});\n\n\ttweenNumber.value = 100;\n}\n\nfunction loop() {\n\n\tvar max = 60 * 5;\n\tvar gray = 0;\n\n\tGL.enable(GL.DEPTH_TEST);\n\tGL.viewport(0, 0, GL.width, GL.height);\n\tfbo.bind();\n\tGL.setMatrices(cameraPersp);\n\tGL.clear(0, 0, 0, 0);\n\n\t//\tWITHOUT BATCH : BIND SHADER THEN DRAW MESH\n\n\t// shader.bind();\n\t// GL.draw(mesh);\n\n\t//\tDRAWING USING BATCH\n\n\t// batch.draw();\n\t// batch2.draw();\n\tshader.uniform(\"time\", \"float\", cnt * .1);\n\n\tshaderUV.bind();\n\tshaderUV.uniform(\"time\", \"uniform1f\", cnt * .1);\n\n\tbatchSphere.draw();\n\tfbo.unbind();\n\n\tGL.setMatrices(cameraOrtho);\n\tGL.disable(GL.DEPTH_TEST);\n\n\tGL.viewport(0, 0, GL.width, GL.height);\n\tbatchCopy.draw(fbo.getTexture());\n\n\tGL.viewport(tweenNumber.value, 0, 200, 200 / GL.aspectRatio);\n\tbatchCopy.draw(fbo.getDepthTexture());\n\n\tGL.viewport(200, 0, 100, 100 * 983 / 736);\n\t// batchCopy.draw(texture);\n\n\tif (cnt++ > max) {\n\t\t// window.location.href = './';\n\t}\n}\n\nfunction resize() {\n\tGL.setSize(window.innerWidth, window.innerHeight);\n\tcameraPersp.setAspectRatio(GL.aspectRatio);\n}\n\n},{\"./DispatcherTest\":1}]},{},[2]);\n"],"file":"bundle.js","sourceRoot":"/source/"}